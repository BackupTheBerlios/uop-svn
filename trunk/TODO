// RASCUNHOS

* para lidar com instancias de entidades (elementos)
 - criar as areas de dados propostas na dissertacao
 - elementlist ???

datastack fica em element ??? talvez mais alguma coisa q ta em
entitydefinition ou RunBytecode vai ir para element...

alias, a implementacao dos opcodes deveria mesmo ficar em runbytecode ???

codigo atual nao funciona com metodos recursivos... sempre q entrar em
um metodo deveria criar espaco para as variaveis locais no registro de
ativacao (naquela outra pilha ???)

///

TAVA NOS RASCUNHOS

rever a lista de testes

sumario dos testes
suite de teste mostrar output, limpar o output antes de rodar um teste, ...

no final do metodo start sempre eh gerado um stop... no final dos outros metodos eh gerado um ret...

---------
sumario dos testes:
numero total testes:xxx
teste1: xxx esperado/status (status)

testes que falharam...

---------

Chamada de metodos s/ parametros e sem retorno
mcall metodo: seta ip->method e ip->ip
empilha na datastack a estrutura ip antes de alterar (para poder retornar)
mcall empilha estrutura IP na datastack ou em outra pilha ???

teste:
def x()
    writeln("antes da chamada")
    y() // geta mcall y
    writeln("depois da chamada")
def y()
    writeln("no metodo y")

---------

///


TODO: juntar symbol e literal, ou uma estende a outra...

DUVIDA: o move eh sobre uma entidade ou sobre um aplicativo em execucao ???

TODO: Tanto no Symbol quanto no Literal, tentar armazenar o tipo "nativo" ao
inves de converter tudo para string... Mas isso pode ser considerado
uma "otimizacao", e nao eh tao necessario assim para logo...

----------------------

* a instrucao da estrutura IP poderia ser um iterator ???

* comecar a usar RAII (auto_ptr e afins) urgentemente

----------------

* Revisar padrões de desenvolvimento de código do projeto
  - Ver o que se aproveita dos padrões discutidos no linkedin
  - http://www.linkedin.com/groupAnswers?viewQuestionAndAnswers=&discussionID=2627816&gid=100895&trk=EML
_anet_qa_ttle-cThOon0JumNFomgJt7dBpSBA

* Ver código da HoloVm para ver o que se aproveita da interface das classes

* Ver código da Cecil para ver o que se aproveita da interface das classes

* Rever arquitetura da UbiVM, tentando esbocar melhor o diagrama de classes

* Opções da linha de comando
  - optimizations == -O0, -O1, -O2, ...

* O próprio addInstruction poderia invocar o método para avaliar otimizações ``simples''

* Ver API da libcecil (ver suas propriedades e métodos)
  - http://mono-project.com/Cecil:FAQ
  - http://anonsvn.mono-project.com/viewvc/trunk/mcs/class/Mono.Cecil/?revision=HEAD

* Imprimir padrões de desenvolvimento

* Tem algo similar ao junit para cpp e c# ???

* Para saber quais temporarias podem ser reutilizadas/liberadas, a cada comando, registrar as temporarias utilizadas para poder libera-las apos o termino do comando. Registrar o tipo no nome da temporaria para facilitar o reuso, tipo stemp999, rtemp999, itemp999, ...


PENDENCIAS
----------
  - Gerar os requires (tipo clausulas when) das entidades, metodos e trechos de codigo...
  - Tabela de opcodes (chave opcode numerico) contendo mnemonico (texto), tipo argumento e ponteiro para metodo que executa o opcode
    - talvez a tabela com os ponteiros deva ser uma tabela separada pq so eh necessaria na UbiVM
  - Tabela de simbolos armazenar os simbolos utilizando os tipos nativos da maquina (quando possivel)
  - 10.20 vira 10.200000... ruim isso...
  - delimitadores de final de comando
  - na suite de testes
    - poder passar o nome de varios testes simultaneamente
    - opcao para exibir a saida de um teste (tipo o .sh q eu fiz)
    - antes de rodar um teste, limpar o output do teste
    - preciso separar entre testes do compilador e da VM ???
    - relatorio dos testes executados
  - usar boost_foreach
  - usar serializacao boost
  - usar multiindex template
    - antes de alterar os fontes, guardar o resultado esperado de cada teste, para poder testar depois...
  - Adicionar .ubil no ubic antes de ler o fonte ???


=== Fluxo de desenvolvimento ===


Alvo: hello_world sendo compilado pelo UbiC e executado pela UbiVM (OK)
------------------------------------------------------------------

* Prototipo do UbiC (OK)
* Prototipo da LibUVM (OK)
* Prototipo da UbiVM (OK)


Alvo: Exibir valores de todos os tipos com writeln (OK)
--------------------------------------------------

* UbiC
  - Gramatica aceitar como argumentos de writeln os tipos boolean, real, integer e string (OK)
  - Gerar ldconst corretamente (OK)
  - Tabela de simbolos comportar varios tipos de dados (OK)
* UbiVM
  - DataStack empilhar/desempilhar literais (OK)
  - Literal tem um tipo, tamanho e a informacao em si (OK)
  - Os tipos integer, real e boolean sao mantidos no proprio literal... string tem um ponteiro para std::string (OK)


Alvo: compilar e executar expressoes matematicas (OK)
------------------------------------------------

* UbiC
  - Alterar gramatica (OK)
  - Complementar descricao dos opcodes (OK)
* LibUVM
  - enums dos novos opcodes (OK)
* UbiVM
  - Implementacao dos novos opcodes (OK)


Alvo: Ambiente de teste automatizado (OK)
------------------------------------

Alvo: Especificar os testes iniciais (basear-se nos testes do HoloC) (OK)
--------------------------------------------------------------------

Alvo: Definir variaveis + inicializar + exibir os valores (somente tipo int) (OK)
----------------------------------------------------------------------------

* UbiC
  - Parser entender definicao de variaveis locais (OK)
  - Parser entender inicializacao de variaveis (OK)
  - Armazenar definicoes variaveis locais e gerar no uvm (OK)
  - Colocar definicao variaveis locais na tabela de simbolos (OK)
  - Criar tabela por metodo com a definicao de variaveis locais (OK)
* UbiVM
  - Carregar definicao de variaveis locais (OK)
  - Ao executar um metodo criar area para as variaveis locais (OK)

Alvo: Definir + inicializar + exibir variaveis de todos os tipos (OK)
----------------------------------------------------------------

Alvo: Expressoes relacionais (tipo int apenas) e booleanas (OK)
----------------------------------------------------------

Alvo: Comandos condicionais (if) para tipo int (OK)
----------------------------------------------

Alvo: Lacos de repeticao (while) para tipo int (OK)
----------------------------------------------

Alvo: Lacos de repeticao (for) para tipo int (OK)
--------------------------------------------

Alvo: Expressoes relacionais para todos os tipos (OK)
------------------------------------------------

Alvo: chamada de metodos na entidade atual
------------------------------------------

Alvo: passagem de parametros para os metodos
--------------------------------------------

Alvo: um retorno nos metodos
----------------------------

Alvo: varios retornos nos metodos
---------------------------------

Alvo: Instanciacao de novas entidades e invocacao de seus metodos
-----------------------------------------------------------------
