// Example of a grammar for parsing Java sources,
// Adapted from Java equivalent example, by Terence Parr
// Author: Jim Idle - April 2007
// Permission is granted to use this example code in any way you want, so long as
// all the original authors are cited.
//

// set ts=4,sw=4
// Tab size is 4 chars, indent is 4 chars

// Notes: Although all the examples provided are configured to be built
//        by Visual Studio 2005, based on the custom build rules
//        provided in $(ANTLRSRC)/code/antlr/main/runtime/C/vs2005/rulefiles/antlr3.rules
//        there is no reason that this MUST be the case. Provided that you know how
//        to run the antlr tool, then just compile the resulting .c files and this
//	  file together, using say gcc or whatever: gcc *.c -I. -o XXX
//	  The C code is generic and will compile and run on all platforms (please
//        report any warnings or errors to the antlr-interest newsgroup (see www.antlr.org)
//        so that they may be corrected for any platofrm that I have not specifically tested.
//
//	  The project settings such as addinotal library paths and include paths have been set
//        relative to the place where this source code sits on the ANTLR perforce system. You
//        may well need to change the settings to locate the includes and the lib files. UNIX
//        people need -L path/to/antlr/libs -lantlr3c (release mode) or -lantlr3cd (debug)
//
//        Jim Idle (jimi cut-this at idle ws)
//

// You may adopt your own practices by all means, but in general it is best
// to create a single include for your project, that will include the ANTLR3 C
// runtime header files, the generated header files (all of which are safe to include
// multiple times) and your own project related header files. Use <> to include and
// -I on the compile line (which vs2005 now handles, where vs2003 did not).
//
//#include    <java.h>
#include "ubilLexer.h"
#include "ubilParser.h"

#include "AssemblyDefinition.hpp"
#include "UbicDefs.hpp"

// The lexer is of course generated by ANTLR, and so the lexer type is not upper case.
// The lexer is supplied with a pANTLR3_INPUT_STREAM from whence it consumes its
// input and generates a token stream as output.
//
static    pubilLexer		    lxr;


//static void	processDir  (char * directory);
static int parseFile   (SParamOptions options);





////////////


// #include "MultiIndex.hpp"
//
// void teste()
// {
// 	MultiIndex<int> mi;
//
// 	mi.add("10", 100);
// 	mi.add("20", 200);
// 	mi.add("30", 300);
//
// 	std::cout << "Numero de itens: " << mi.size() << std::endl;
//
// 	for(MultiIndex<int>::iterator item = mi.begin(); item != mi.end(); item++) {
// 		std::cout << "item: key[" << (*item).key << "] value[" << (*item).value << "]" << std::endl;
// 	}
//
// 	std::cout << "Chave 10 valor " << mi.get("10") << std::endl;
// 	std::cout << "Chave 20 valor " << mi.get("20") << std::endl;
// 	std::cout << "Chave 30 valor " << mi.get("30") << std::endl;
//
// 	std::cout << "Indice 0 valor " << mi.get(0) << std::endl;
// 	std::cout << "Indice 1 valor " << mi.get(1) << std::endl;
// 	std::cout << "Indice 2 valor " << mi.get(2) << std::endl;
//
// 	exit(0);
// }


////////////


void showVersion() {
   std::cerr << "UbiC 0.1.0" << std::endl;
   //std::cerr << rcstagid << " (" << rcsrevid << ")" << endl;
}

void showSyntax(int valor) {
    std::cout << "Use: ubic [options] filename" << std::endl;
    std::cout << "\t-o\tDefine uvm output filename." << std::endl;
	std::cout << "\t-a\tDefine assembly output filename." << std::endl;
	std::cout << "\t-A\tDefine high level assembly output filename." << std::endl;
	std::cout << "\t-h\tShow this help." << std::endl;
    std::cout << "\t-v\tShow version." << std::endl;
    std::cout << std::endl;
    std::cout << "To report bugs: alexgarzao@gmail.com " << std::endl;
//    std::cout << "To report bugs: " << PACKAGE_BUGREPORT << std::endl;

    exit(valor);
}



// Main entry point for this example
//
int ANTLR3_CDECL
main	(int argc, char *argv[])
{
// 	teste();

    	showVersion();

	SParamOptions options;

	int param;
	while ((param = getopt(argc, argv, "a:A:o:hv")) != -1) {
		switch (param) {
			case 'a': // Make assembly text file
				options.asmFilename = std::string(optarg);
				break;
			case 'A': // Make high level assembly text file
				options.hlasmFilename = std::string(optarg);
				break;
			case 'o': // Output uvm filename
				options.uvmFilename = std::string(optarg);
				break;
			case 'v': // Version
//				showVersion();
				exit(1);
				break;
			case 'h': // Help
				showSyntax(1);
				break;
			default: // Other options
				showSyntax(1);
				break;
		}
	}

	argc -= optind;
	argv += optind;

    if (argc == 0) {
        std::cerr << "Error: Undefined filename..." << std::endl;
        showSyntax(EXIT_FAILURE);
    }

    options.sourceFilename = std::string(argv[0]) + ".ubil";
//     options.sourceFilename = std::string(argv[0]);
	if (options.uvmFilename.empty()) {
		options.uvmFilename = std::string(argv[0]) + ".uvm";
//		options.uvmFilename = options.sourceFilename.substr(0, options.sourceFilename.size()-4) + "uvm";
	}
//         for (param = 1; param < argc; param++)
//             options.parameters.push_back(Symbol(argv[param]));

//        try {
//            if (!options.quiet)
//                showVersion();
//            VirtualMachine vm(&options);
//            vm.run();
//        } catch (HVMException hvme) {
//            cout << hvme.getErro() << endl;
//            exit(EXIT_FAILURE);
//        }
//    }


//	std::cout << "sourceFilename=" << options.sourceFilename << std::endl;
//	std::cout << "uvmFilename=" << options.uvmFilename << std::endl;
//	std::cout << "asmFilename=" << options.asmFilename << std::endl;


	// Create the input stream based upon the arguement supplied to us on the command line
	// for this example, the input will always default to ./input if there is no explicit
	// argument, otherwise we are expecting potentially a whole list of 'em.
	//
//	if (argc < 2 || argv[1] == NULL)
//	{
//		exit(1);
//		processDir("./input"); // Note in VS2005 debug, working directory must be configured
//	}

	int error = parseFile(options);
	//parseFile((pANTLR3_UINT8)argv[1]);
//	else
//	{
//		int i;
//
//		for (i = 1; i < argc; i++)
//		{
//			processDir(argv[i]);
//		}
//	}

//    printf("Finished. Parsing OK.\n");	// Finnish parking is pretty good - I think it is all the snow
    printf("*finished parsing OK\n");	// Finnish parking is pretty good - I think it is all the snow

    if (error > 0) {
		fprintf(stderr, "The parser returned %d errors.\n", error);

		return 1; // TODO: usar define correto
	}

	return EXIT_SUCCESS;
}


/*
static void
processDir(char * directory)
{
    unsigned char     buf[2048];
    DIR		    * Hdir;
    DIR		    * Hdirs;
    struct dirent   * dirfil;

    // First, determine if we have been given a directory or a file
    //
    Hdir    = opendir((const char *)directory);

    if (Hdir == NULL)
    {
	// It was no a directory, therefore we assume that it was a file
	//
	parseFile((pANTLR3_UINT8)directory);
    }
    else
    {
		do
		{
			// We successfully opened a directory, we iterate all
			// subdirectories and find all files within all directories
			//
			dirfil	= readdir(Hdir);

			if	(      dirfil != NULL			// Out of entries in this directory
					&& dirfil->d_name[0] != '.' // Current or prior directory, or hidden file
				)
			{
				int buflen;

				// We found a new entry in this directory, we need to know
				// if it is a sub directory of course.
				//
				buflen = sprintf((char *)buf, "%s%c%s", directory, DIRDELIM, dirfil->d_name);
				Hdirs	= opendir((const char *)buf);

				if (Hdirs != NULL)
				{
					// This was a directory too, close the reference here, and call
					// ourselves recursively, to process this subdirectory
					//
					processDir((char *)buf);
					closedir(Hdirs);
					printf(" %s\n", buf);
				}
				else
				{
					// This is a local file, if it is a .java file, then
					// let's parse it.
					//
					if (       (buf[buflen-4] == 'j' || buf[buflen-4] == 'J')
						&& (buf[buflen-3] == 'a' || buf[buflen-3] == 'A')
						&& (buf[buflen-2] == 'v' || buf[buflen-2] == 'V')
						&& (buf[buflen-1] == 'a' || buf[buflen-1] == 'A')
						)
					{
						// // printf("  - %s\n", dirfil->d_name);
						//printf(" S"); fflush(stdout);
						parseFile((pANTLR3_UINT8) buf);
						// putc('E', stdout); fflush(stdout);
					}
				}
			}

		} while (dirfil != NULL);

	// This directory is complete, close this level and return
	//
	closedir(Hdir);
	printf("\n");
	return;
    }
}
*/

static int parseFile(SParamOptions options)
//parseFile(pANTLR3_UINT8 fName)
{
    // Now we declare the ANTLR related local variables we need.
    // Note that unless you are convinced you will never need thread safe
    // versions for your project, then you should always create such things
    // as instance variables for each invocation.
    // -------------------

    // The ANTLR3 character input stream, which abstracts the input source such that
    // it is easy to provide input from different sources such as files, or
    // memory strings.
    //
    // For an ASCII/latin-1 memory string use:
    //	    input = antlr3NewAsciiStringInPlaceStream (stringtouse, (ANTLR3_UINT64) length, NULL);
    //
    // For a UCS2 (16 bit) memory string use:
    //	    input = antlr3NewUCS2StringInPlaceStream (stringtouse, (ANTLR3_UINT64) length, NULL);
    //
    // For input from a file, see code below
    //
    // Note that this is essentially a pointer to a structure containing pointers to functions.
    // You can create your own input stream type (copy one of the existing ones) and override any
    // individual function by installing your own pointer after you have created the standard
    // version.
    //
    pANTLR3_INPUT_STREAM    input;


    // The token stream is produced by the ANTLR3 generated lexer. Again it is a structure based
    // API/Object, which you can customise and override methods of as you wish. a Token stream is
    // supplied to the generated parser, and you can write your own token stream and pass this in
    // if you wish.
    //
    pANTLR3_COMMON_TOKEN_STREAM	    tstream;

    // The C parser is also generated by ANTLR and accepts a token stream as explained
    // above. The token stream can be any source in fact, so long as it implements the
    // ANTLR3_TOKEN_SOURCE interface. In this case the parser does not return anything
    // but it can of course specify any kind of return type from the rule you invoke
    // when calling it.
    //
    pubilParser				psr;

    // Create the input stream using the supplied file name
    // (Use antlr3AsciiFileStreamNew for UCS2/16bit input).
    //
    pANTLR3_UINT8 fName = (pANTLR3_UINT8)options.sourceFilename.c_str();
    input	= antlr3AsciiFileStreamNew(fName);

    // The input will be created successfully, providing that there is enough
    // memory and the file exists etc
    //
    if ( input == NULL )
    {
		fprintf(stderr, "File not found: %s\n", (char *)fName);
	    exit(1);
    }

    // Our input stream is now open and all set to go, so we can create a new instance of our
    // lexer and set the lexer input to our input stream:
    //  (file | memory | ?) --> inputstream -> lexer --> tokenstream --> parser ( --> treeparser )?
    //
    if (lxr == NULL)
    {
		lxr	    = ubilLexerNew(input);	    // javaLexerNew is generated by ANTLR
    }
	else
	{
		lxr->pLexer->setCharStream(lxr->pLexer, input);
	}

    // Need to check for errors
    //
    if (lxr == NULL)
    {
	    fprintf(stderr, "Unable to create the lexer due to malloc() failure1\n");
	    exit(ANTLR3_ERR_NOMEM);
    }

    // Our lexer is in place, so we can create the token stream from it
    // NB: Nothing happens yet other than the file has been read. We are just
    // connecting all these things together and they will be invoked when we
    // call the parser rule. ANTLR3_SIZE_HINT can be left at the default usually
    // unless you have a very large token stream/input. Each generated lexer
    // provides a token source interface, which is the second argument to the
    // token stream creator.
    // Note that even if you implement your own token structure, it will always
    // contain a standard common token within it and this is the pointer that
    // you pass around to everything else. A common token as a pointer within
    // it that should point to your own outer token structure.
    //
    tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));

    if (tstream == NULL)
    {
		fprintf(stderr, "Out of memory trying to allocate token stream\n");
		exit(ANTLR3_ERR_NOMEM);
    }

    // Finally, now that we have our lexer constructed, we can create the parser
    //
    psr	    = ubilParserNew(tstream);  // javaParserNew is generated by ANTLR3

    if (tstream == NULL)
    {
		fprintf(stderr, "Out of memory trying to allocate parser\n");
		exit(ANTLR3_ERR_NOMEM);
    }

    // We are all ready to go. Though that looked complicated at first glance,
    // I am sure, you will see that in fact most of the code above is dealing
    // with errors and there isn't really that much to do (isn't this always the
    // case in C? ;-).
    //
    // So, we now invoke the parser. All elements of ANTLR3 generated C components
    // as well as the ANTLR C runtime library itself are pseudo objects. This means
    // that they are represented as pointers to structures, which contain any
    // instance data they need, and a set of pointers to other interfaces or
    // 'methods'. Note that in general, these few pointers we have created here are
    // the only things you will ever explicitly free() as everything else is created
    // via factories, that allocate memory efficiently and free() everything they use
    // automatically when you close the parser/lexer/etc.
    //
    // Note that this means only that the methods are always called via the object
    // pointer and the first argument to any method, is a pointer to the structure itself.
    // It also has the side advantage, if you are using an IDE such as VS2005 that can do it,
    // that when you type ->, you will see a list of all the methods the object supports.
    //
    //putc('L', stdout); fflush(stdout);
	//{
	//	ANTLR3_INT32 T;

	//	T = 0;
	//	while	(T != ANTLR3_TOKEN_EOF)
	//	{
	//		T = tstream->tstream->istream->_LA(tstream->tstream->istream, 1);
	//		tstream->tstream->istream->consume(tstream->tstream->istream);
	//		printf("%d %s\n", T,  (psr->pParser->rec->state->tokenNames)[T]);
	//	}
	//}
    tstream->tstream->_LT(tstream->tstream, 1);	// Don't do this normally, just causes lexer to run for timings here
    //putc('P', stdout); fflush(stdout);
//    SParamOptions param;
//    param.asmFilename = "aaa.asm";
//    param.uvmFilename = "aaa.uvm";
    psr->compilation_unit(psr, options);
//    printf("Retorno [%s]\n", psr->compilation_unit(psr).c_str());
    //putc('F', stdout); fflush(stdout);
    /*putc('*', stdout);*/ fflush(stdout);

//    printf("Retorno [%s]\n", psr->retabc);

	int errors = psr->pParser->rec->state->errorCount;

	if (errors == 0) {
		if (options.asmFilename != "") {
			std::ofstream out(options.asmFilename.c_str(), std::ios_base::out);
			out << get_asm_def()->toTextAssembly(false);
		}
		if (options.hlasmFilename != "") {
			std::ofstream out(options.hlasmFilename.c_str(), std::ios_base::out);
			out << get_asm_def()->toTextAssembly(true);
		}
		get_asm_def()->saveBytecode(options.uvmFilename);
	}


    // We did not return anything from this parser rule, so we can finish. It only remains
    // to close down our open objects, in the reverse order we created them
    //
    psr	    ->free  (psr);	    psr	    = NULL;
    tstream ->free  (tstream);	    tstream = NULL;
    lxr	    ->free  (lxr);	    lxr	    = NULL;
    input   ->close (input);	    input   = NULL;

	return errors;
}



/*

//////////////////////// COPIADO GPT /////////////////
//
//
//

#include "config.h"

#include "GPTDisplay.hpp"
#include "GPT.hpp"

#include <sstream>
#include <string>
#include <list>
#include <unistd.h>

using namespace std;

enum {
  FLAG_DICA  = 0x1
};

enum {
  CMD_SHOW_VERSION,
  CMD_SHOW_HELP,
  CMD_COMPILE,
  CMD_INVALID
};

//----- globals ------

int    _flags = 0;
list<string> _ifilenames;

string _csource;
string _asmsource;
string _binprogram;

//----- Options -----

static int init(int argc, char** argv) {

  if(argc == 1) {
    return CMD_SHOW_HELP;
  }

  stringstream s;
  int cmd = CMD_COMPILE;
  opterr = 0;
  int c;
  int count_cmds = 0;

//
//  Opcoes:  o: <output>,  t: <output>,  s: <output>, H: <host>,  P: <port>,  h[help]
//           v[ersion],  i[nterpret],  p[ipe],  d[ica]
//

#ifndef DEBUG
  while((c = getopt(argc, argv, "o:c:s:H:P:idvh")) != -1) {
    switch(c) {
#else
  while((c = getopt(argc, argv, "o:t:s:H:P:idvhD")) != -1) {
    switch(c) {
#endif
      case 'o':
        count_cmds++;
        cmd = CMD_COMPILE;
        if(optarg) {
          _binprogram = optarg;
        }
        break;
      case 'd':
        _flags |= FLAG_DICA;
        break;
      case 'v':
        return CMD_SHOW_VERSION;
        break;
      case 'h':
        return CMD_SHOW_HELP;
        case '?':
           if((optopt == 'o') || (optopt == 't')) {
            s << PACKAGE << ": faltando argumento para opção -" << (char)optopt << endl;
           } else {
            s << PACKAGE << ": opção inválida: -" <<  char(optopt) << endl;
           }
           GPTDisplay::self()->showError(s);
           goto bail;
     default:
        s << PACKAGE << ": erro interno." << endl;
        GPTDisplay::self()->showError(s);
        goto bail;
    }
  }

  if(count_cmds > 1) {
    s << PACKAGE << ": mais de um comando selecionado." << endl;
    GPTDisplay::self()->showError(s);
    goto bail;
  }

    c = optind;
    while(c < argc) {
      _ifilenames.push_back(argv[c++]);
    }

    if(_ifilenames.size() == 0) {
      s << PACKAGE << ": nenhum arquivo especificado." << endl;
      GPTDisplay::self()->showError(s);
      goto bail;
    }

  return cmd;

  bail:
    return CMD_INVALID;
}


static void appendDefaultFiles() {
  string inc;

  char* env = getenv("GPT_INCLUDE");

  if(!env || strlen(env) == 0) {
    return;
  }

  inc = env;

  string filename;
  string::size_type c = 0;
  string::size_type b = 0;
  while((c = inc.find(":", b)) != string::npos) {
    filename = inc.substr(b, c);
    if(filename.length()) {
      _ifilenames.push_back(filename);
    }
    b = c+1;
  }
  filename = inc.substr(b);
  if(filename.length()) {
    _ifilenames.push_back(filename);
  }
}

int main(int argc, char** argv) {
  int cmd = init(argc, argv);
  bool success = false;
  stringstream s;

  if(_flags & FLAG_DICA) {
    GPT::self()->reportDicas(true);
  } else {
    GPT::self()->reportDicas(false);
  }

  appendDefaultFiles();


  switch(cmd) {
    case CMD_SHOW_VERSION:
      GPT::self()->showVersion();
      break;
    case CMD_SHOW_HELP:
      GPT::self()->showHelp();
      break;
    case CMD_COMPILE:
      if(!_binprogram.empty()) {
        GPT::self()->setOutputFile(_binprogram);
      }
      success = GPT::self()->compile(_ifilenames);
      break;
    case CMD_INVALID:
      break;
  }

  return success?EXIT_SUCCESS:EXIT_FAILURE;
}

*/



